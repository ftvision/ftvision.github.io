---
title: 写完10000行C++之后
subtitle:
layout: wide6_anchorlink
tags: [short-notes,]
date: 2019-02-01
lang: cn
---

从去年七月到今年一月，我写完了工作后的第一个10,000行C++代码。虽然2015年实习的时候也写过一个暑假的C++，但是之前是游戏工作室，使用C++其实也只是用其中C的子集，甚至可以说是用一个Visual Studio来编译`cpp`后缀名的c文件。过去半年就大不一样，代码库是真材实料的C++，而且很多还是C++11的风格和语法。所以，我最多算一个0.5起点的C++程序员。

从这半年写的10,000行C++代码里面，我学到的不仅仅是C++语言的语法和特性，还有关于软件工程的一些知识：设计、测试、遗留代码、代码审查、版本控制等等。这个总结就分为两部分吧。

## 10k行后的C++感受

开始工作后的第一件事情就是学习C++。不过C++这门语言在C++11之后变化之大，让我确实感受到了Bjarne Stroustrup所说：
> C++是一门新的语言。

C++变化巨大，变得越来越复杂，但是也越来越有意思。同时，C++与C的距离也越来越远。面对两种语言当前的差距，我觉得学习今天的C++，确实是没有必要从C开始了：很多C语言的表达方式不被推荐，一些C语言的语言特性在C++中更好的选择。学习C和学习C++确实应该被当做两件独立的事情了。

### 全新的“表达欲”

C++11以来，语言变得越来越具有表达性了[^1]。Peter Van Roy在[计算机编程范式](https://www.edx.org/course/paradigms-of-computer-programming-fundamentals)中曾说道现代程序语言有往“声明式编程(declarative programming)”转变的趋势。从C++的转变来看，确实有这个意思。

比如说`range_for`这样的新语法，使得循环语句能够直接将关心的对象作为目标变量，而不再需要用下标索引来访问。`auto`的引入进一步简化了复杂的语法。这样一方面能够让处理内部元素的逻辑更加清晰，另一方面也能减少诸如下标访问非法的错误。
```c++
for (auto element : collection) {
  // 专心处理关心的对象element。
  // 不用被下标索引等冗余分心。
}
```
这样的表达方式很早就在Python之类的语言里面有了。不过在语法和思考方式上，这种`for`循环的写法都和之前的方法不一样，所以经常发现代码的结构和设计都自然地偏向原始的`for`循环。而一些有C/C++背景的人去写python的时候也时不时会习惯性地用“丑陋的”下标来写循环语句。
```python
for element in collection:
  # 专心处理对象element。
```

我之前关于C++的印象就是我需要写很多指令来告诉C++一步一步具体怎么做。而我更喜欢Python这门语言的原因之一也是Python的语言表达性使得我写的代码更短、更易读、更好理解。不过这半年的C++11的体验让我觉得现代的C++还是很令人愉悦的：C++11以来全新的表达能力让我觉得C++的表达欲更强烈，表达内容也更加清晰明快。

要说让我强烈地感受到C++的新的表达能力的强大的，要数Sean Parent一系列关于“更好的代码”的讲座([讲座1](https://www.youtube.com/watch?v=0WlJEz2wb8Y)，[讲座2](https://www.youtube.com/watch?v=QGcVXgEVMJg)，[讲座3](https://www.youtube.com/watch?v=IzNtM038JuI))和[资料](https://sean-parent.stlab.cc/presentations/2013-09-11-cpp-seasoning/cpp-seasoning.pdf)，都非常的精彩。当整屏幕的代码最后被两三行的语句所代替的时候，那种美感和满足感真的是难以言表。

### 写有风格的C++

代码是写给人看的，编译器会把人写的代码编译为机器能看懂的代码。所以，人就专心做好人要做的事情，让编译器去专心做编译器要做的事情。C++是一门可以接触到机器底层的语言，也有很多语言技巧可以提高C++程序的性能，结果这个领域经常出现一些奇技淫巧。提高性能当然是好事，但是看得懂代码的人少，学得懂代码的人更少，这就会影响代码库的维护。虽然其中一些奇技淫巧已经成为了固定的套路（或者说是常用模式），但是还是有很多的技巧晦涩又危险。

这种感觉在我进入现在工作的这个巨大的代码库的时候变得十分强烈。读代码就好像读文章一样。一段简洁清晰的代码能让人很快地理解这段意思和推理这段代码的行为，正如一篇简洁明了的文章能快速传达文章要义，激发读者的想象。而一段晦涩的代码，如一篇晦涩的文章一样，让人不知所云。虽然作家可以尽情地寻找和发挥自己喜欢的风格，但是程序员最好还是追求一种简洁清晰的代码风格为好。毕竟编程也是一种社交活动[^3]，而写软件通常都是靠团队合作。

不同的程序语言通常有不同的风格。比如Python社区就有很好的风格指导[^4]，而具有Python风格的代码被认为是“Pythonic Style”。相比而言，C++的风格就没有那么成型。一方面是因为语言本身特性庞杂、变化多端，另一方面是可能是因为各自为政、各有所需，常常没有一个可以覆盖各个公司/开发者的需求的风格指南。这其中，比较有名的，也被吐槽的比较严重的莫过于[Google的C++风格指南](https://google.github.io/styleguide/cppguide.html)了。这份风格之南在过去几年中已经有了不少的改变，但是主要还是针对Google自己的代码库、程序员背景和产品需求来设计的。很多规定对其他开发项目并不合适，看到被吐槽的点，我觉得双方都应该被理解。作为更普适的风格指南，当前C++社区正在制定和书写的[C++核心指南](https://github.com/isocpp/CppCoreGuidelines)可能会比较好。

由于工作的需要，我自然需要先学习和理解我们自己的风格指南。通读全篇文章倒不用花费很长的时间，但是真正要在日常的代码书写中跟着要求走却是一件不容易的事情。更别说在指南之外还有160多个建议，我这10,000行代码的经验也就学到了个零头。写完了10,000行代码以后，注意了代码审阅中所有的知识点，还是经常被**C++可读性**学习项目的评审人轻易地指出20来个修改建议。

### 最感兴趣的两个专题

写完10,000行以后，我现在最想好好搞清楚的是两个专题：生命周期(lifetime)和资源所有权(resource ownership)。

生命的周期也就是一个对象从“生”到“死”的时间线。C++里面有全局变量，局部变量，静态变量，类内部静态与非静态成员变量，动态构造的指针变量等等，每一种变量都有自己的逻辑和生命周期。即使是同一类的变量，生命周期也有先后顺序。

对生命周期感兴趣主要是因为在写过的代码里面出现的几次重大问题都和变量生命周期没有搞清楚有关。比如没有搞清楚变量构造和析构的先后顺序，导致非法访问已经释放的空间。又比如没有搞清楚局部静态变量的构造时间点，导致提前访问了还没有分配的空间。更不要说面对网络通讯和多线程计算之类的问题的时候，我现在也很难理清各种变量产生和消亡的时间点，通常就想放弃推理，交给同事来审阅代码。这一部分，接下来要好好学习一下。

资源所有权跟生命周期息息相关。除了只能在对象存在的时候才能安全地访问对象所持有的资源（比如内存）中的数据之外，还要推理动态分配资源的所有权的转移问题。比如“智能指针(smart pointers)”这一类抽象类型的引入，就强调了指针对其指向的内存的所有权的管理。`std::unique_ptr`是相对比较好理解的，所以也在我们的风格之南中被高度推荐，而`std::shared_ptr`之类对于内存所有权的管理需要计算和跟踪，对开发者来说推理难度增大，所以经常不被推荐[^5]。除此之外，还有移动语意(move semnatics)、返回值优化(return value optimization)之类的语法概念，都使得资源所有权的推理变得更加复杂。

C++11以来似乎越来越注重如何安全地管理资源，因此也更新了以上一系列的语法概念。作为初学者，我觉得学起来确实还挺难的。主要是刚开始接触这些概念的时候，感觉非常抽象。只有多写，多经历一些实际的例子之后，可能才能习惯。10,000行代码，肯定是远远不够的。

### 难点概念和特性

10,000行代码毕竟只是一个开始，很多C++的语言概念和特性我都还似懂非懂。希望自己能够在写完20,000行前理解这些语言特性。

1. *右值(Rvalue)*。

2. *移动和复制语意(move and copy semantics)* 

3. *资源获取即初始化(Resource Acquisition Is Initialization, RAII)*

4. *运行时类型信息(Runtime Type Information, RTTI)*

5. *参数依赖查找(Argument-Dependent Lookup, ADL)*

6. *线程与并发(Thread & Concurrency)* 

7. *回调(Callbacks)与`std::function`*

除此之外，我在阅读中第一次体会到很多常用的数据，比如时间和字符串，处理起来原来是异常的复杂。之前编程只觉得字符串处理非常繁琐。后来才知道，时间的计算和处理更加困难，边界条件多得数不过来。想一想时区的更变，各个国家各个文化的日历，以及著名的千年虫和[2038问题](https://en.wikipedia.org/wiki/Year_2038_problem)[^6]。有时候很庆幸我不负责写这些底层逻辑，只是用写好的时间库就可以了。

### 接下来的路

10,000行C++仅仅只是个开始。我所使用过的C++语言特性还只是非常少的一部分。C++的语言学习还有很长的路要走。希望在20,000行Code之后能够写出初具风格的C++代码，以及对一些比较重要的C++语言特性和概念有比较好的把握。

---

## 10k行后的软件工程感受

我之前并没有软件工程方面的背景，即使是计算机科学相关的内容，我也仅限于能够写码，以及对数据结构与算法有基本的了解[^2]。包括面向对象在内各种设计模式完全是一窍不通，而软件开发方面的工程步骤也是不了解多少。过去六个月，因为我各种经验都缺乏，所做的项目比较琐碎，没有什么复杂的涉及。虽然感觉缺少了影响，但是也还是学到了不少东西。

### 代码审阅

代码提交之前需要互相审阅，这是工作中最让我受益匪浅的一环。尤其是我现在作为一个菜鸟，经常能够从前辈的审阅意见中学到很多知识，包括如何写好的代码，好的注释，好的设计，好的思维方式。牛逼的前辈经常能洞察到的被我疏忽的逻辑漏洞，他们的审阅意见因此预防了很多可能产生的[幺蛾子](https://www.zhihu.com/question/59445070/answer/345045044)(bug)。

我记得我第一次接触到代码审阅是在2015年的实习。当时我就发现，能在代码审阅中感受到一个程序员的经验和智慧。现在也是，有些审阅人草草了事，有些审阅人斤斤计较。而真正牛逼的审阅人往往可以一针见血地指出我的程序中的漏洞，给出意见的时候主次分明，态度友善，看得我心服口服。

### 测试

测试，各种测试：单元测试，集成测试，负载测试。我开始工作的这半年里，一半的代码量都是在写测试。可以说，我是在用写测试的方式来学习C++，而不是通过写业务逻辑。经常一次代码提交，业务逻辑也就写了100多行，但是附带的测试可能写了300多行。而且我写的测试还不一定覆盖了所有的逻辑，也不一定覆盖了所有的代码。

写测试真的是一个技术活。尤其是我发现自己需要维护的代码中，很多以前的测试写得非常糟糕。要不就是只考虑一种情况，要不就是只考虑正常的、符合预期的逻辑链，而不考虑可能引起错误的逻辑分支。最糟糕的情况那就是不写测试了。

不写测试的原因也有很多种。其中最有趣的问题是：要不要为测试代码写测试？很多时候，测试代码是直接靠人眼和人脑进行推理的，这些代码是没有其他的代码进一步保证其正确性的。然而，只要是人在做事情，人就一定会犯错。但是，如果要为测试代码写测试的话，新写的代码要不要继续被更多的代码测试？如此递推下去可不行。

所以，我们对于单元测试就直接人脑推理，不用其他代码了。不过，集成测试和负载测试通常是需要用独立的测试工具来实现的。这些测试工具本身的正确性，至少应该由一定的单元测试来检验。不然，就会沦落到我现在的处境：我们有一个3000行的测试工具，内部代码70%都没有被测试过。结果现在想淘汰或者想修改这个工具都非常困难。

另外，测试驱动的开发(Test-Driven Development)还是蛮有用的，尤其是在代码重构和代码淘汰的时候（泪流满面，都是教训）。

### 版本控制，回撤，前推

版本控制实在是太重要了。这一点学术界做的非常非常不好。现在不仅仅有Git这类的对代码的版本控制，Dropbox、Google Docs之类的软件对很多类型的文件和数据都有了版本控制。真是好事！

版本控制的好处不仅仅在于能够看到数据修改的历史，还在于能够在各种版本之间切换，从而帮助新产品的迭代。另外，我觉得版本控制也使得安全性增加，开发者们也能感受到*更强的心理安全感*。比如，如果新的代码出现了问题，代码库可以及时回撤(Roll back)到之前稳定的版本。与此同时，开发者可以回过头来分析到底是出现了什么问题。代码更新，问题解决之后，写的代码又可以前推(Roll forward)到代码库中。如果新版本没问题，开发继续；如果又有问题，大不了就重来一次。而且，只要主版本是稳定的，不同的开发者之间一般互不耽误。

本来我以为单元测试覆盖得足够好，我应该不会需要经历回撤这种操作。但是没想到过去的半年中还是回撤了三次。幸亏我们有健全的版本控制系统，所以也算是有惊无险。不然，即使我们有“不责难(Blameless)”的文化，我也不会大胆地去写代码。

另外，不同的版本控制软件的不同思路也很有趣。比如，Git和Perforce对于代码版本组织的不同决策就很有意思。虽然现在主要是Git的天下，但是某些巨大的代码库不能够用Git的逻辑来控制版本，而是选择了Perforce的变体，让我第一次对版本控制所面临的规模扩展性问题有了认识。规模大起来，真是连细小琐碎的事情都显得复杂。

### 历史遗留代码

过去半年，我算是真正见识到了技术债(tech debt)。我现在主攻的问题之一就是重构一个3000多行、测试不够、设计混杂的工具。这个项目我已经写了四个月了，现在还没有完成一半。原因之一是我的C++基础本来就薄弱；另一个原因就是这段代码实在是太乱了。我看我们组没有人真的愿意花精力理清其中的逻辑。但是这是一个我们每天都要使用的重要工具啊！我也是服气的。于是，我本着借此机会学习C++的想法开始修改这段代码。硬骨头，真难啃。不过，这还只是我们代码库中比较小的问题了。在我们庞大的代码库中，不知道有多少这样的历史遗留问题没有得到妥善安置。但问题是，没什么人愿意花时间精力来清理这些债务。毕竟这是一件费力不讨好事情：不一定被同事认可你做出的贡献，也不会成为你的升职之路的垫脚石。

遗留代码的另一个问题就是：公司内部工具的用户界面，真的是一个丑啊。很多界面都是十几年没改过了。虽然我理解后端程序员不太关心这个，但是很多时候，界面已经丑到影响工作效率的地步了。结果我发现，面对这些问题，大家的方式就跟面对所有技术债一样，强行通过时间来熟悉和适应。这应该是我觉得工作中最不合理的一部分了。

### 软件工程设计

作为一名新手，过去10,000代码解决的问题都很琐碎。我也没有太多的机会深入学习软件设计。日常的工作，其实对设计模式和分布式计算的知识要求也不高。所以，这些知识看起来还是得业余时间多看书才能学习。至于算法设计，那更是从来没看见过。想到这一点，还是有一些遗憾的。

话虽如此，经验还是教会了我一些知识的。

- 设计要把界面(interface)和实现(implementation)分开
: 这个道理说起来很容易，但是真正做起来还真是需要从代码实践中学习。很多时候，我觉得两者分离得已经挺不错的了，结果代码审阅的时候还是被指出实现手段没有被封装好。
- 异常处理
: 作为一个不允许使用`exception`的公司，处理异常的手段可能是不太一样。不过话说回来，我也没有用`exception`处理异常的经验，所以禁止使用`exception`对我来说倒是影响不大。经过这半年的折腾，我觉得：
    1. 早死早超生。如果程序刚刚启动没多久就有错误，干脆早点报错终止程序，不要等到抛传了一系列错误之后，时间过去了，结果还是没有办法恰当处理错误，该死的还是要死。
    2. 即使病入膏肓，也要把问题浮出表面在死。在大型项目中，有些异常是深藏在代码深处的，经历了一层套一层的函数传递。如果这个时候见到异常就终止程序，反而不是一个好选择。一方面失去了重试的机会，另一方面也不好调试。比如我写的主程序，结果深藏的一个并没有那么重要的小库出现了异常，这点问题可能对主程序并不重要，没了数据主程序还能跑。如果这个小库导致的异常就直接终止程序，那就得不偿失了。我有一个项目，做的就是把藏得较深的报错终止逻辑去掉，然后把错误状态一层一层传回主程序，让主程序决定是继续还是去死。
    3. 优雅地处理错误。其实异常处理最难的不是传递错误状态，也不是抛出一些`exception`，而是思考如何优雅地处理错误，从异常中恢复，然后继续代码的逻辑。要做到这个，往往比抛出异常需要更多的脑力和逻辑思维。抛出异常是好，但是如果把抛出异常当做甩锅的手段，把问题都留给其他的开发者，这对整个开发团队的效率也会有负面的影响的。

---
**注：**

[^1]: Expressive这个说法是我从博客“[Fluent C++](https://www.fluentcpp.com/)”第一次学到的。可能我有点过时了，但是这个说法确实让我眼前一亮。 
[^2]: 我对数据结构与算法的了解也主要来自于中学计算机竞赛。本科以及之后就没有再系统地学习过这一方面的知识了。虽然之前的知识斩掉一般公司的面试题没什么大问题，但算法和数据结构毕竟只是码农工作中很小的一部分。
[^3]: Github不就被戏称为全球最大同性交友网站么。
[^4]: 比如纲领性的[The Zen of Python](https://www.python.org/dev/peps/pep-0020/)，
[^5]: 开发者对于某项语法的理解难度通常是我们风格指南考虑是否推荐这项语法的因素，这也是被很多人吐槽的一点。不过说实话，我们这很多码农可能是我这样的C++普通玩家，要让大多数码农都能写出比较正确的代码，我觉得这是可以理解的。
[^6]: 2038问题也跟《斯坦因之门》紧密相关啊。
