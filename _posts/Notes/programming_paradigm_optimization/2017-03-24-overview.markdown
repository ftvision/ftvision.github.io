---
layout: single
title: Programming Paradigm Overview
permalink: /programming_paradigm_overview
modified: 2017-03-24
---

## Un-organized

### OOP

OOP is based on the sending of messages to objects. Objects respond to messages by performing operations. Messages can have arguments, so "sending messages" looks a lot like calling subroutines. A society of objects, each with their own "local memory" and own set of operations has a different feel than the "monolithic processor and single shared memory" feel of non object oriented languages.

### Functional programming
In functional programming control flow is expressed by combining function calls, rather than by assigning values to variables.

With functional programming

- There are no commands, only side-effect free expressions
- Code is much shorter, less error-prone, and much easier to prove correct
- There is more inherent parallelism, so good compilers can produce faster code

## Overview

### imperative paradigm: First do this and next do that

Characteristics:

- Discipline and idea
    - Digital hardware technology and the ideas of Von Neumann
- Incremental change of the program state as a function of time.
- Execution of computational steps in an order governed by control structures
    - We call the steps for commands
- Straightforward abstractions of the way a traditional Von Neumann computer works
- Similar to descriptions of everyday routines, such as food recipes and car repair
- Typical commands offered by imperative languages
    - Assignment, IO, procedure calls
- Language representatives
    - Fortran, Algol, Pascal, Basic, C
- The natural abstraction is the procedure
    - Abstracts one or more actions to a procedure, which can be called as a single command.
    - "Procedural programming"

### functional paradigm: Evaluate an expression and use the resulting value for something

Characteristics:

- Discipline and idea
    - Mathematics and the theory of functions
- The values produced are non-mutable
    - Impossible to change any constituent of a composite value
    - As a remedy, it is possible to make a revised copy of composite value
- Atemporal
    - Time only plays a minor role compared to the imperative paradigm
- Applicative
    - All computations are done by applying (calling) functions
- The natural abstraction is the function
    - Abstracts a single expression to a function which can be evaluated as an expression
- Functions are first class values
    - Functions are full-fledged data just like numbers, lists, ...
- Fits well with computations driven by needs
    - Opens a new world of possibilities


### Logic paradigm: Answer a question via search for a solution

The logic paradigm fits extremely well when applied in problem domains that deal with the extraction of knowledge from basic facts and relations. The logical paradigm seems less natural in the more general areas of computation.

Characteristics:

- Discipline and idea
    - Automatic proofs within artificial intelligence
- Based on axioms, inference rules, and queries.
- Program execution becomes a systematic search in a set of facts, making use of a set of inference rules

### Object-oriented paradigm: Send messages between objects to simulate the temporal evolution of a set of real world phenomena

Characteristics:

- Discipline and idea
    - The theory of concepts, and models of human interaction with real world phenomena
- Data as well as operations are encapsulated in objects
- Information hiding is used to protect internal properties of an object
- Objects interact by means of message passing
    - A metaphor for applying an operation on an object
- In most object-oriented languages objects are grouped in classes
    - Objects in classes are similar enough to allow programming of the classes, as opposed to programming of the individual objects
    - Classes represent concepts whereas objects represent phenomena
- Classes are organized in inheritance hierarchies
    - Provides for class extension or specialization


### Declarative Programming (Prolog, SQL)

Declarative programming has been around for many years, but most programmers are still unaware of it as a concept. Here’s the gist: in most mainstream languages, you describe how to solve a particular problem; in declarative languages, you merely describe the result you want, and the language itself figures out how to get there.

If you’ve used SQL, you’ve done a form of declarative programming and may not have realized it: when you issue a query like select X from Y where Z, you are describing the data set you’d like to get back; it’s the database engine that actually figures out how to execute the query. You can use the explain command in most databases to see the execution plan and figure out what happened under the hood.
