---
layout: single
title: Functions
permalink: /coding101/function
prev: 
late:
topic: Programming Introduction
topiclink: /coding101/
---

#Functions
Variables and parameters are *local* When you create a variable inside a function, it is local, which means that it only exists
inside the function. For example:

```python
def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
```

```c++
void cat_twice(int part1, int part2):
    int cat = part1 + part2
    printf("%d\n", cat)
```

cat is local

To keep track of which variables can be used where, it is sometimes useful to draw a stack diagram. Like state diagrams, stack diagrams show the value of each variable, but they also show the function each variable belongs to.

Each function is represented by a **frame**. A frame is a box with the name of a function beside it and the parameters and variables of the function inside it. The stack diagram for the previous example is shown in Figure 3.1.


If an error occurs during a function call, Python prints the name of the function, and the name of the function that called it, and the name of the function that called that, all the way back to `__main__`.

Some of the functions we are using, such as the math functions, yield results; for lack of a better name, I call them **fruitful functions**. Other functions, like print_twice, perform an action but don’t return a value. They are called **void functions**.

##Importing

`import math`
`from math import pi`
`from math import * #import everythin`

As you should expect by now, you can call one function from within another. This ability is called **composition**.


A **method** is similar to a function—it takes arguments and returns a value—but the syntax is different. For example, the method upper takes a string and returns a new string with all uppercase letters:

```new_word = word.upper()```

A method call is called an invocation; in this case, we would say that we are invoking upper on the word.


## Global and Local

frame called `__main__`. Variables in `__main__` are sometimes called global because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.
It is common to use global variables for flags; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named verbose to control the level of detail in the output:

Python: If the global value is mutable, you can modify it without declaring it


# Closure and Decorator
## This is a difficult concept

[12 Steps for python decorator](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/)

It turns out that, against our expectations, our returned inner function does work. Python supports a feature called function closures which means that inner functions defined in non-global scope remember what their enclosing namespaces looked like at definition time. This can be seen by looking at the func_closure attribute of our inner function which contains the variables in the enclosing scopes.

From this example you can see that closures - the fact that functions remember their enclosing scope - can be used to build custom functions that have, essentially, a hard coded argument. 

A decorator is just a callable that takes a function as an argument and returns a replacement function. We’ll start simply and work our way up to useful decorators.




