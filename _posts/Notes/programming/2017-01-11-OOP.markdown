---
layout: mathnote
title: Class and Object
permalink: /coding101/OOP
prev: 
late: 
topic: Programming Introduction
topiclink: /coding101/

---

User-defined types

The **class object** is like a factory for creating objects. To create a Point, you call Point as if it
were a function.


```
>>> blank = Point()
>>> print blank
<__main__.Point instance at 0xb7e9d3ac>
```

The return value is a reference to a Point object, which we assign to blank. Creating a new object is called instantiation, and the object is an instance of the class.

In this case, though, we are assigning values to named elements of an object. These elements are called **attributes**.

In Python. Objects are mutable. You can change the state of an object by making an assignment to one of its attributes. For example, to change the size of a rectangle without changing its position, you can modify the values of width and height.

##Copying objects

Aliasing can make a program difficult to read because changes in one place might have unexpected effects in another place. It is hard to keep track of all the variables that might refer to a given object.

Copying an object is often an alternative to aliasing. The copy module contains a function called copy that can duplicate any object:

Pure Function:

In the next few sections, we’ll write two functions that add time values. They demonstrate two kinds of functions: pure functions and modifiers. They also demonstrate a develop- ment plan I’ll call **prototype and patch**, which is a way of tackling a complex problem by starting with a simple prototype and incrementally dealing with the complications.

Sometimes it is useful for a function to modify the objects it gets as parameters. In that case, the changes are visible to the caller. Functions that work this way are called modifiers.
**increment**, which adds a given number of seconds to a Time object, can be written naturally as a modifier.

In general, I recommend that you write pure functions whenever it is reasonable and resort to modifiers only if there is a compelling advantage. This approach might be called a functional programming style.

The development plan I am demonstrating is called “prototype and patch.” For each function, I wrote a prototype that performed the basic calculation and then tested it, patching errors along the way.

This approach can be effective, especially if you don’t yet have a deep understanding of the problem. But incremental corrections can generate code that is unnecessarily complicated—since it deals with many special cases—and unreliable—since it is hard to know if you have found all the errors.

An alternative is planned development, in which high-level insight into the problem can make the programming much easier. In this case, the insight is that a Time object is really a three-digit number in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal.)! The second attribute is the “ones column,” the minute attribute is the “sixties column,” and the hour attribute is the “thirty-six hundreds column.”


Python is an object-oriented programming language, which means that it provides fea-
tures that support object-oriented programming.
It is not easy to define object-oriented programming, but we have already seen some of its characteristics:

• Programs are made up of object definitions and function definitions, and most of the computation is expressed in terms of operations on objects.
• Each object definition corresponds to some object or concept in the real world, and the functions that operate on that object correspond to the ways real-world objects interact.

This observation is the motivation for **methods**; a method is a function that is associated with a particular class. We have seen methods for strings, lists, dictionaries and tuples. In this chapter, we will define methods for user-defined types.

Methods are semantically the same as functions, but there are two syntactic differences:
• Methods are defined inside a class definition in order to make the relationship be- tween the class and the method explicit.
• The syntax for invoking a method is different from the syntax for calling a function


By convention, the first parameter of a method is called `self`, so it would be more common to write print_time like this:


The reason for this convention is an implicit metaphor:
• The syntax for a function call, print_time(start), suggests that the function is the active agent. It says something like, “Hey print_time! Here’s an object for you to print.”
• In object-oriented programming, the objects are the active agents. A method invoca- tion like start.print_time() says “Hey start! Please print yourself.”

This change in perspective might be more polite, but it is not obvious that it is useful. In the examples we have seen so far, it may not be. But sometimes shifting responsibility from the functions onto the objects makes it possible to write more versatile functions, and makes it easier to maintain and reuse code.

#Printing __str__

#Operator Overload

By defining other special methods, you can specify the behavior of operators on user- defined types. For example, if you define a method named `__add__` for the Time class, you can use the `+` operator on Time objects.
[Python operator overload](http://docs.python.org/2/reference/datamodel.html#specialnames)

##Type-based Dispath (see code)

#Polymorphism

Functions that can work with several types are called polymorphic. Polymorphism can facilitate code reuse. For example, the built-in function sum, which adds the elements of a sequence, works as long as the elements of the sequence support addition.


#information hiding

Keeping the interface separate from the implementation means that you have to hide the attributes. Code in other parts of the program (outside the class definition) should use methods to read and modify the state of the object. They should not access the attributes di- rectly. This principle is called information hiding; see http://en.wikipedia.org/wiki/ Information_hiding.


#Inheritance

The language feature most often associated with object-oriented programming is inher- itance. Inheritance is the ability to define a new class that is a modified version of an existing class.

It is called “inheritance” because the new class inherits the methods of the existing class. Extending this metaphor, the existing class is called the parent and the new class is called the child.

Inheritance is a useful feature. Some programs that would be repetitive without inheritance can be written more elegantly with it. Inheritance can facilitate code reuse, since you can customize the behavior of parent classes without having to modify them. In some cases, the inheritance structure reflects the natural structure of the problem, which makes the program easier to understand.

On the other hand, inheritance can make programs difficult to read. When a method is invoked, it is sometimes not clear where to find its definition. The relevant code may be scattered among several modules. Also, many of the things that can be done using inheritance can be done as well or better without it.


There are several kinds of relationship between classes:

• Objects in one class might contain references to objects in another class. For example, each Rectangle contains a reference to a Point, and each Deck contains references to many Cards. This kind of relationship is called **HAS-A**, as in, “a Rectangle has a Point.”

• One class might inherit from another. This relationship is called **IS-A**, as in, “a Hand is a kind of a Deck.”

• One class might depend on another in the sense that changes in one class would require changes in the other.

#developing a class

This example suggests a development plan for designing objects and methods:

1. Start by writing functions that read and write global variables (when necessary).

2. Once you get the program working, look for associations between global variables and the functions that use them.

3. Encapsulate related variables as attributes of an object.

4. Transform the associated functions into methods of the new class.


#Event-Driven Programming

The value of the command option is a function object, which is known as a **callback** because after you call bu to create the button, the flow of execution “calls back” when the user presses the button.

This kind of flow is characteristic of event-driven programming. User actions, like but- ton presses and key strokes, are called events. In event-driven programming, the flow of execution is determined by user actions rather than by the programmer.
The challenge of event-driven programming is to construct a set of widgets and callbacks that work correctly (or at least generate appropriate error messages) for any sequence of user actions.

A binding is an association between a widget, an event and a callback: when an event (like a button press) happens on a widget, the callback is invoked.
Many widgets have default bindings. For example, when you press a button, the default binding changes the relief of the button to make it look depressed. When you release the button, the binding restores the appearance of the button and invokes the callback specified with the command option.


Classes Are Like Modules

You can think about a module as a specialized dictionary that can store Python code so you can access it with the . operator. Python also has another construct that serves a similar purpose called a class. A class is a way to take a grouping of functions and data and place them inside a container so you can access them with the . (dot) operator.

Objects are Like Import

If a class is like a "mini-module," then there has to be a similar concept to import but for classes. That concept is called "instantiate", which is just a fancy, obnoxious, overly smart way to say "create." When you instantiate a class what you get is called an object.

You instantiate (create) a class by calling the class like it's a function, like this:

[Term in python](https://learnpythonthehardway.org/book/ex41.html)


OOP design: The process is as follows:

- Write or draw about the problem.
- Extract key concepts from 1 and research them.
- Create a class hierarchy and object map for the concepts.
- Code the classes and a test to run them.
- Repeat and refine.

# Abastract Class 

- [python](https://docs.python.org/3.5/library/abc.html)
- [c++](http://www.cplusplus.com/doc/tutorial/polymorphism/#abstract_base_classes)
- [polymorphism](https://www.wikiwand.com/en/Polymorphism_(computer_science))

This type of class can have abstract methods as well as defined methods, but it cannot be instantiated (meaning you cannot create a new instance of it). To use an abstract class, you must create and instantiate a subclass that extends the abstract class. Any abstract methods declared in an abstract class must be implemented by its subclasses (unless the subclass is also abstract).

Both Abstract and Non-Abstract methods can be overwritten

**When you have abstract method, you cannot instantiate a new object**. Only when you implemenented all the methods, can you instantiate a new object ==> you can use a new class that `extends` the original class.


# Interface 

Recall that abstraction is the separation between what something does and how it's accomplished. An interface is a collection of abstract methods and constants that form a common set of base rules/specifications for those classes that implement it. Much like an abstract class, an interface cannot be instantiated and must be implemented by a class. 

- This is mainly a Java feature because Java can only inherit from one class.
- C++ and Python can have multiple inheritance.
- C++ has it
- Python doesn't have it
  - Python doesn't support interfaces(and doesn't need to). Python has powerful multiple inheritance anyways, so languages like Java which have single inheritance only have to cope by inculcating "implementable" interfaces.

# Generic

Generic constructs are a very efficient way of reusing your code. In the same way you have parameters for a function, generics parameterize type and allow you to use apply the same interface, class, or method using different data types while still restricting operations to that data type (meaning that you still get strong type checking at compile time). 

Sounds confusing? You've already used generics in more than one challenge! Consider the List and Map interfaces, as well as the classes that implement them. Their respective headings are:

```
public interface List<E> extends Collection<E>
public interface Map<K,V>
```

The letters enclosed between angle brackets (< and >) are type parameters and, like many things in programming, there is a convention behind them (remember, following conventions help us write clean, readable code!). The letters below are commonly-used generic type parameters:

E - Element
K - Key
V - Value
N - Number
T - Type (e.g.: data type)
S,U,V, etc. These are second, third, and fourth types for when T is already in use. 

This is the same as [C++ Templates](http://www.cplusplus.com/doc/oldtutorial/templates/)
<div>
  <!-- Nav tabs -->
  <ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active"><a href="#cpp" aria-controls="cpp" role="tab" data-toggle="tab">C/C++</a></li>
    <li role="presentation"><a href="#python" aria-controls="python" role="tab" data-toggle="tab">Python</a></li>
  </ul>

  <!-- Tab panes -->
  <div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="cpp">
    		<pre> <code class="c++">
{% include helloworld.cpp %}
				</code></pre>
	</div>
    <div role="tabpanel" class="tab-pane" id="python"> 	
    		<pre> <code class="python">

            {% include helloworld.cpp %}

				</code>
<p><strong>最好的注意的是：</strong>这个不容易</p> 	
		</pre>   	
    </div>
  </div>

</div>



