---
layout: mathnote
title: Functions
permalink: /coding101/function
prev: 
late:
topic: Programming Introduction
topiclink: /coding101/
---

#Functions
Variables and parameters are *local* When you create a variable inside a function, it is local, which means that it only exists
inside the function. For example:

```
def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
```
cat is local

To keep track of which variables can be used where, it is sometimes useful to draw a stack diagram. Like state diagrams, stack diagrams show the value of each variable, but they also show the function each variable belongs to.

Each function is represented by a **frame**. A frame is a box with the name of a function beside it and the parameters and variables of the function inside it. The stack diagram for the previous example is shown in Figure 3.1.


If an error occurs during a function call, Python prints the name of the function, and the name of the function that called it, and the name of the function that called that, all the way back to `__main__`.

Some of the functions we are using, such as the math functions, yield results; for lack of a better name, I call them **fruitful functions**. Other functions, like print_twice, perform an action but don’t return a value. They are called **void functions**.

##Importing

`import math`
`from math import pi`
`from math import * #import everythin`

As you should expect by now, you can call one function from within another. This ability is called **composition**.


A **method** is similar to a function—it takes arguments and returns a value—but the syntax is different. For example, the method upper takes a string and returns a new string with all uppercase letters:

```new_word = word.upper()```

A method call is called an invocation; in this case, we would say that we are invoking upper on the word.


## Global and Local

frame called `__main__`. Variables in `__main__` are sometimes called global because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.
It is common to use global variables for flags; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named verbose to control the level of detail in the output:

Python: If the global value is mutable, you can modify it without declaring it

<div>
  <!-- Nav tabs -->
  <ul class="nav nav-tabs" role="tablist">
    <li role="presentation" class="active"><a href="#cpp" aria-controls="cpp" role="tab" data-toggle="tab">C/C++</a></li>
    <li role="presentation"><a href="#python" aria-controls="python" role="tab" data-toggle="tab">Python</a></li>
  </ul>

  <!-- Tab panes -->
  <div class="tab-content">
    <div role="tabpanel" class="tab-pane active" id="cpp">
    		<pre> <code class="c++">
{% include helloworld.cpp %}
				</code></pre>
	</div>
    <div role="tabpanel" class="tab-pane" id="python"> 	
    		<pre> <code class="python">

            {% include helloworld.cpp %}

				</code>
<p><strong>最好的注意的是：</strong>这个不容易</p> 	
		</pre>   	
    </div>
  </div>

</div>



